<!--
 * @Descripttion:
 * @version:
 * @Author: congsir
 * @Date: 2022-04-25 22:25:01
 * @LastEditors: Please set LastEditors
 * @LastEditTime: 2022-07-12 11:36:31
-->
> 对伪元素的动态设置可以通过动态类来实现

如写一個伪元素的类，当需要伪元素出现时，给目标元素加上类，不需要则去掉类

> 只使用步骤条的左侧

1.将组件宽度设置好左侧条的宽度 2.之后将右侧内容与步骤条的父元素进行 flex row 布局即可 3.注意要将步骤条内类进行高度及宽度固定，有些需要 display：inline-block

> 下拉刷新更新更多历史

- 一个内容框有多个日期，每个日期有多个记录，故使用二维数组
- 第一次因为没有当前日期，故第一次直接加入到一个数组项且初始化当前日期
- 设置一个当前日期
  - 如果当前记录的日期等于当前日期则加入一个数组项
  - 若不等于，那么将数组项加到总数组中，然后将当前记录加入到一个新的数组项，设置新的当前日期
- 因为初始化时最后一个记录肯定没机会(走了第一个选项)加入到总数组，因此需要设置初始化时最后额外将数组项加入到总数组
- 之后刷新获取更多记录
- 对第一个记录进行判断(因为时间最邻近可能是同日期)

  - 若该记录的日期与总数组第一项中的日期相同，那么设置当前日期，并将总数组第一项复制给数组项，再将记录加入到数组项
    - 因为当前这次刷新获取的记录是直接加入到之前总数组里的，故不能重复加入
    - 进行判断如果总数组的第一项的第一个记录 id 等于当前数组项的第一个记录 id，说明两个数组是一样的，则不再加入
  - 若不同，那么没有当前日期，第一次直接加入到一个数组项且初始化当前日期

- 将接口英文和中文提取\`\s(.)+\s\'
- 提取中文\'[\u4e00-\u9fa5]+\'

- 对表单中 input 进行聚焦可以在行内使用 focus="{{item.focus}}"
- 之后检测时查看该字段的 require 和 value，若不满足 require 则设置 foces 为 true 聚焦
- 表单检测报错语句使用 item.err 来判断是否显示

> 怎么处理大量数据

- 使用分页，每次获取部分数据
- 下拉刷新获取数据
- 对于纯展示不需要变化的数据使用 Object.freeze 冻结(失去响应性)，减少 observer 和内存开销

```ts
this.item = Object.freeze(Object.assign({}, this.item));
```

scroll-view 滑动需要设置高度及滑动方向，若出现两条滑动条，说明 scorll-view 高度太大

> ant design react 表单

- 日期回显，如果初始化值为 moment，那么直接赋值，否则 moment(日期)
- 单/多选框回显，将初始化的值处理为和组件 value 同样的值即可
- 图片上传回显，将 url 数组处理为一个个 fileList 对象然后放入数组即可
- form.setFieldValues()传入数据对象即可回显

> 权限路由

+ 第一种先设置基础路由,之后设置路由守卫第一次进入时判断身份，之后过滤路由，再通过addRoute添加额外的路由
+ 第二种设置完整路由，之后设置路由守卫在每次进入时判断是否能进入

> 权限菜单

+ 先写好完整菜单，之后通过后端传的权限对菜单进行过滤

>按钮权限

+ v-if判断当前路由的路由元的权限属性
+ v-指令判断，先将权限列表放在localstorage，之后判断，如果没有权限则el.parentNode.removeChild(el)删除该按钮

> 跨域

+ cors 只需要在后端设置即可
  + 如果是简单请求get post head 则只需要设置'Access-Control-Allow-Origin'为 '*'
  + 如果是复杂请求 除简单请求方法外的，则要设置Access-Control-Allow-Origin，Access-Control-Allow-Headers，Access-Control-Allow-Methods
+ 使用代理
  + 在vue.config.js里设置
```ts
module.exports = {
    devServer: {
        host: '127.0.0.1',
        port: 8084,
        open: true,// vue项目启动时自动打开浏览器
        proxy: {
            '/api': { // '/api'是代理标识，用于告诉node，url前面是/api的就是使用代理的
                target: "http://xxx.xxx.xx.xx:8080", //目标地址，一般是指后台服务器地址
                changeOrigin: true, //是否跨域
                pathRewrite: { // pathRewrite 的作用是把实际Request Url中的'/api'用""代替
                    '^/api': ""
                }
            }
        }
    }
}
```
注意设置基础路径`axios.defaults.baseURL = '/api'`
+ jsonp 进行跨域

> sso单点登录

多系统登录

+ 首先用户访问系统1，发现未登录则跳转到sso认证中心并以自身地址做参数
+ 在认证中心发现未登录，没有可登录的令牌
+ 进行登录，登录成功后会创建全局会话以及授权令牌
+ 将重定向并把令牌作为参数返回给系统1
+ 系统1拿着令牌去访问认证中心，验证令牌成功后重定向回系统一，系统1用令牌创建局部会话
+ 服务器返回资源给浏览器
+ 之后用户想要登录系统2，首先发现未登录然后跳转到sso认证中心并以自身地址做参数
+ 在认证中心验证登录了之后返回一个令牌并重定向回系统2
+ 系统2再拿着这个令牌去认证中心验证，验证令牌成功后重定向回系统2，系统2用令牌创建局部会话
+ 服务器返回资源给浏览器