#### 组件化和模块化
+ 模块化是文件层面上对代码和资源的拆分
+ 组件化是设计层面上对UI的拆分

### 工程化的理解
+ 使用webpack对项目进行构建
+ 使用babel完成js的编译
+ 项目模块化开发
+ 组件化开发
+ 使用MOCK解决前后端开发的协调问题
+ 对代码进行规范化约束
+ 项目部署流程化

### 对模块化的理解
+ 提高复用性
+ 更好的分离，按需加载
+ 更高的维护性
+ 避免命名冲突
+ CommonJS规范
  + 导出方式exports，module.exports
  + 导入方式require()
  + require是同步操作
  + 导入的值是拷贝形式
+ AMD(Async Module Definition异步模块定义,RequireJS)
  + 必须先声明依赖的模块
  + 解决两个问题
    + 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器
    + js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长
+ CMD(Common Module Definition通用模块定义)
  + 需要把文件解析完才知道依赖哪些模块

+ 模块实现
  + 函数
  + 对象
  + 立即执行函数
  + 单独文件
```ts
//立即执行函数
var module = (function(){
　　var star = 0;
　　var f1 = function (){
　　　　console.log('ok');
　　};
　　var f2 = function (){
　　　　//...
　　};
     return {
        f1:f1,
        f2:f2
     };
})();
module.f1();  //ok
console.log(module.star)  //undefined
```
### 闭包使用场景
+ 通过闭包来给内部函数传参
+ 延长变量的生命周期
+ 柯里化函数
+ 模拟私有方法(返回一个带有私有方法的对象)
+ 创建私有变量(返回一个带有私有变量的对象)

```ts
function f1(a) {
    function f2() {
        console.log(a);
    }
    return f2;
}
var fun = f1(1);
setTimeout(fun,1000);//一秒之后打印出1
```

>注意await是promise的语法糖
```ts
console.log(1)
new Promise(resolve =>{
    console.log(7)
    for(let i=0; i<9000;i++){
        if(i==666)resolve(i)
    }
}).then(val=>{
    console.log(val)
})
async function fo(){
    console.log(2)
    await go()
    console.log(4)
}
async function go(){
    console.log(3)
}
fo()
console.log(6)
//1 7 2 3 6 666 4
----------------------------------------------------------------
async function fo(){
    console.log(2)
    await go()
    console.log(4)
}
相当于
function fo(){
    console.log(2)
    new Promise(()=>{
      go()
    }).then(()=>{
      console.log(4)
    })
}
```

## 发出跨域请求时过程
XMLHttpRequest遵守同源策略(same-origin policy)，发出跨域请求时，浏览器会根据需要(非简单请求)发起一次预检（也就是option请求），用来让服务端返回允许的方法（如get、post），被跨域访问的Origin（来源或者域），还有是否需要Credentials(认证信息)等。

>option请求：
由CORS引发的option请求，它是一种探测性的请求，通过这个方法，客户端可以在采取具体资源请求之前，了解服务器性能或需求，黑客常见的办法就是用option来试探。

在ajax跨域请求时，如果请求的是json，或者一些其他‘非简单请求’，此时需要提前发出一次options请求，用以检查请求是否是可靠安全的，如果options获得的回应是拒绝性质的，比如404\403\500等http状态，就会停止post、put等请求的发出，或者报错。

>满足下列三大条件，就属于简单请求，否则属于非简单请求

1.请求方式只能是：GET、POST、HEAD

2.HTTP请求头限制这几种字段：Accept、Accept-Language、Content-Language、Content-Type、Last-Event-ID

3.Content-type只能取：application/x-www-form-urlencoded、multipart/form-data、text/plain

>简单请求：
  对于简单请求浏览器直接请求，会在请求头信息中，增加一个origin字段，来说明本次请求来自哪个源（协议+域名+端口）。服务器根据这个值，来决定是否同意该请求，服务器返回的响应会多几个头信息字段：

1.Access-Control-Allow-Origin：该字段是必须的，如果后台将其设置为* 表示接受任意域名的请求，还可以指定域名。（表示允许访问的外域请求）

2.Access-Control-Allow-Credentials：该字段可选，是个布尔值，表示是否可以携带cookie，（注意：如果Access-Control-Allow-Origin字段设置*，此字段设为true无效）

3.Access-Control-Allow-Headers：该字段可选，里面可以获取Cache-Control、Content-Type、Expires等，如果想要拿到其他字段，就可以在这个字段中指定。比如图中指定的GUAZISSO

4.Access-Control-Expose-Headers：该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。（首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字段，允许用户头部携带（修改）哪些字段）

>非简单请求：
 对服务器有特殊要求的请求的，例如请求方式是PUT或者DELETE，或者自己配置请求头要求修改Content-Type字段类型是application/json。都会在正式通信之前，增加一次HTTP请求(options请求)，称之为预检。浏览器会先询问服务器，当前网页所在域名是否在服务器的许可名单之中，服务器允许之后，浏览器会发出正式的XMLHttpRequest请求，否则会报错。

> dns缓存

游览器缓存->操作系统缓存->路由器缓存->本地域名服务器DNS缓存->根域名服务器搜索

> 解决跨域问题

> vue优点
+ 轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 kb ；
+ 简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；
+ 双向数据绑定：保留了 angular 的特点，在数据操作方面更为简单；
+ 组件化：保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势；
+ 视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；
+ 虚拟DOM：dom 操作是非常耗费性能的，不再使用原生的 dom 操作节点，极大解放 dom 操作，但具体操作的还是 dom 不过是换了另一种方式；
+ 运行速度更快：相比较于 react 而言，同样是操作虚拟 dom，就性能而言， vue 存在很大的优势。

> TCP与UDP

>cors头部带什么信息

+ 请求方法是以下三种方法之一：
  + HEAD
  + GET
  + POST
+ HTTP的头信息不超出以下几种字段：
  + Accept
  + Accept-Language
  + Content-Language
  + Last-Event-ID
  + Content-Type：
    + application/x-www-form-urlencoded、 multipart/form-data、text/plain

不满足这些特征的请求称为“非简单请求”，例如：content-type=applicaiton/json , method = PUT/DELETE

>content-type的类型，form-data可以传对象吗
可以，使用FormData对象

>promise all 怎么分别捕捉错误
+ 给promise.all数组的promise设置catch，这样不会走promise.all的catch，而是自身promise的catch然后再走promise.all的then
+ 将错误处理reject都设置为resolve
+ 使用promise.settled

>怎么判断链表有环
+ 给每个节点加上ID，然后蛮力遍历(两重循环)
+ 快慢指针，一前一后，前面的走得慢(前进一个next)，后面的走得快(前进两个next),如果有环则快指针会追上慢指针
> 什么是类数组


>两个类名及顺序
```js
//style
.a{
  color:green;
}
.b{
  color:red;
}
.a.b{
  color:yellow;
}
.b.a{
  color:black;
}
//html
<a class="a b"/>//black
<a class="b a"/>//black
```
选择的节点与classList有关，和类名顺序无关，故.a.b{}会被.b.a{}覆盖