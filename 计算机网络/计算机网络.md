这是一个链接 [浏览器知识点](https://juejin.cn/post/6916157109906341902/)
<https://juejin.cn/post/6916157109906341902/>

# 浏览器安全
> XSS攻击
>
> 1.跨站脚本攻击，是一种代码注入攻击，攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等
> 2.XSS 的本质是因为网站没有对恶意代码进行过滤
> 3.攻击者可以通过这种攻击方式可以进行以下操作：
>> 获取页面的数据，如DOM、cookie、localStorage；
>> DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；
>> 破坏页面结构；
>> 流量劫持（将链接指向某网站）；

4.XSS 可以分为存储型、反射型和 DOM 型：
+ 存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。
+ 反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。
+ DOM 型指的通过修改页面的 DOM 节点形成的 XSS。

## 强缓存和协商缓存
> 浏览器在第一次请求文件资源时，会把资源缓存在本地，同时缓存响应头

> 强缓存:首先检查缓存的响应头expires或者cache-control中的max-age是否过期，如果未过期，那么直接到缓存去获取资源。如果已过期，那么进行协商缓存。

> 协商缓存：直接拿着请求头的if-modified-since去和服务器的last-modified比较，若两者相同说明资源未修改过，那么去缓存获取资源返回304；若不相同，那么直接请求最新资源返回200，并更新last-modified
> last-modified缺点：只能精确到秒
> ETag:基于资源内容生成的标识字符串，为解决last-modified问题,用来指示url对象是否变化。拿着ETag与服务器生成的ETag进行比较，如果一致则说明未改变，那么去缓存获取资源返回304；若不相同，那么直接请求最新资源返回200。

## 使用CSP限制各类资源的加载，能预防XSS攻击
>CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。

>通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式

### 前端优化：DNS预解析提升页面速度

- 现象：前端访问不同域名外的域名文件可能会比较慢，出现请求延时的情况。

- 出现原因：

  - 对方网站的宽带或负载原因（少数）
  - 网速原因（也有一定可能）
  - DNS解析的速度原因

- 处理：

  - 预解析，在页面的header添加下方代码

  - ```html
    <meta http-equiv="x-dns-prefetch-control" content="on" />
    <link rel="dns-prefetch" href="http://bdimg.share.baidu.com" />
    <link rel="dns-prefetch" href="http://nsclick.baidu.com" />
    <link rel="dns-prefetch" href="http://hm.baidu.com" />
    <link rel="dns-prefetch" href="http://eiv.baidu.com" />
    ```

- 游览器对网站第一次域名DNS解析查找过程如下

  - 游览器缓存->操作系统缓存->路由器缓存->ISP DNS缓存-->递归搜索

- 页面预解析实现：

  - 首先用meta信息告知游览器，做DNS预解析

    ```html
    <meta http-equiv="x-dns-prefetch-control" content="on"/>
    ```

  - 在header页面中使用link强制对DNS预解析

    ```html
    <link rel="dns-prefetch" href="http://bdimg.share.baidu.com" />
    ```

- 注：

  - dns-prefetch慎用，多页面的DNS预先解析会则增加DNS查询次数


> DNS缓存查询过程
+ 浏览器缓存查询是否有该域名对应的IP地址
+ 到操作系统中查询是否有该域名对应的IP地址
+ 在路由器中查询
+ 发送DNS请求到本地域名服务器查询
  + 若有则递归查询
  + 若无，向根域名服务器发起DNS请求进行迭代查询

> DNS递归查询
主机-> 本地域名服务器 -> 根域名 -> 顶级域名服务器-> 权限域名服务器
之后权限域名服务器返回结果，返回给主机

> DNS迭代查询
本地域名服务器 -> 根域名(返回指定的顶级域名服务器)
本地域名服务器 -> 顶级域名服务器(返回指定权限域名服务器)
本地域名服务器 -> 权限域名服务器(返回IP)


> HTTP1.0

新增了请求头和响应头进行协商，告诉服务器请求内容，类型，期待返回内容类型，压缩格式，文件编码格式，cookie等。

>HTTP1.1

改进了连接持久化，解决建立关闭连接的开销，支持在一条连接上传输多个HTTP请求（最大6个）

> HTTP2.0

支持多路复用，设置请求优先级，服务器推送，对请求响应头进行压缩

> 同站

顶级域名和二级域名以及协议相同即同站

同站：zhuanlan.zhihu.com和zhihu.com。.com属于顶级域名，而.zhihu属于二级域名。这里属于同站，但是跨域了。

跨站： zhihu.com和baidu.com、a.github.io和b.github.io。第一个例子虽然顶级域名相同，但是二级域名不一样了。第二个例子看起来会觉得奇怪，这里github.io属于顶级域名，a和b才是二级域名，所以这里也跨站了。

再比如，http://a.zhihu.com和https://zhuanlan.zhihu.com，虽然顶级域名和二级域名相同zhihu.com，但是因为他们的协议不同，也属于跨站。

看完例子后，可以给个简单的结论：跨站一定跨域，跨域不一定跨站。

> sameSite

开头就有提到，SameSite属性可以让 Cookie 在跨站请求时不会被发送，从而阻止了跨站请求伪造攻击（CSRF）。它有三个属性值

Strict 完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。
Lax 允许部分第三方请求携带 Cookie。
None 无论是否跨站都会发送 Cookie。
注意SameSite=none 只支持HTTPS接口。如果要设置该值，需要在对应的Cookie上同时设置Secure属性。

Chrome的SameSite默认值是Lax，而Safari的默认值是Strict。

!()[https://pic3.zhimg.com/80/v2-6b477e810bb54ea8ca4462e44f9be87e_720w.jpg]

>网络模型

+ 七层网络模型(OSI)
  + 物理层
  + 数据链路层
  + 网络层
  + 传输层
  + 会话层
  + 表示层
  + 应用层
+ 四层网络模型(TCP/IP)
  + 网络接口层
  + 网际层
  + 运输层
  + 应用层
+ 五层网络模型
  + 物理层
  + 数据链路层
  + 网络层
  + 传输层
  + 应用层

http1.1是半双工，而http2.0是全双工

> http1会有队头阻塞问题

![](https://pic4.zhimg.com/80/v2-cfb84e854d1bf335ea60c432a8c334a7_720w.jpg?source=1940ef5c)

队头阻塞(head of blocking)，队头阻塞问题会导致带宽无法充分利用，导致后续的请求被阻塞。
假如有五个请求被同时发出，如果第一个请求没有处理完成，就会导致后续的请求也无法得到处理，如下图所示

> http1.1管道化

![](https://pica.zhimg.com/80/v2-1684686f2ba81d48afd27033317a5ab1_720w.jpg?source=1940ef5c)

+ 可以用来解决队头阻塞
+ 只有幂等的请求比如 GET、HEAD 才能使用 pipelining ，非幂等请求比如 POST 则不能使用，因为请求之间可能存在先后依赖关系
+ 队头阻塞问题并没有完全解决，因为服务器返回的响应还是要依次返回

> 什么是 stream？

stream 是连接中的一个虚拟信道，可以承载双向消息传输。每个流有唯一整数标识符。为了防止两端 streaam id 冲突，客户端发起的流具有奇数 id，服务器端发起的流具有偶数 id。

我们上面提到 HTTP 1.x 没有真正解决连接共享还有一个主要的因素就是无法对不同的请求设置优先级，这样会导致关键请求被阻塞。而 HTTP 2.0 你可以对不同的 stream 设置不同的优先级，stream 之间也可以设置依赖，依赖和优先级都可以动态调整，这样就会解决关键请求被阻塞的问题。

帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流。
流就是多个帧组成的数据流。


> http2.0

+ 是彻底的二进制协议，分为首部帧和数据帧
+ 实现了多路复用
+ 实现头部压缩，可以避免重复传输相同的头部来减少传输体积(因为通信双方会各自缓存请求的头部字段)
+ 服务器能够在客户端未发出请求时主动推送资源
+ 使用了数据流的概念

> 消息

指逻辑上的HTTP消息，比如请求，响应(http包)，是由一个或多个帧组成

> 帧

帧代表着最小的数据单位
承载特定类型的数据，如http首部，负荷等


> 实现多路复用

+ http2.0每个消息在tcp连接中分为分为头信息帧和数据帧
+ 之后帧会组装成一个流进行传输
+ 最后在接收端，不同的帧根据各自流id进行判断然后组装完整


> 为什么http1不能实现多路复用

由于 HTTP 1.X 是基于文本的，因为是文本，就导致了它必须是个整体，在传输是不可切割的，只能整体去传。

计算题

https://blog.csdn.net/qq_31881541/article/details/53239634?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-53239634-blog-49099035.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-53239634-blog-49099035.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=2

> TCP三次握手丢包

+ 第一次握手丢包,客户端没收到服务端的确认报文，得知丢包了于是重传
+ 第二次握手丢包,客户端没收到服务端的确认报文，得知丢包了于是重传，而服务端收不到第三次握手的ack包，也会进行重传
+ 第三次握手丢包，服务端没收到再次确认报文，得知丢包于是重传()
+ 注意一二三次握手重传到一定次数则会主动释放连接
+ 第三次握手丢包，重传一定次数后服务端单方面释放连接，但客户端是建立连接状态
  + 第一种可能是客户端不发送数据，在存活期后自动释放连接
  + 第二种是发送数据后没有收到服务器的确认，重传，一定次数后释放连接

https://blog.csdn.net/qq_45788043/article/details/120399740#:~:text=%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%20%E7%9A%84%E4%B8%A2%E5%8C%85%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%E7%9A%84%E6%AC%A1%E6%95%B0%E9%99%90%E5%88%B6%E5%92%8CRTO%E7%9A%84%E5%A2%9E%E9%95%BF%20%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%88syn%E5%8C%85%EF%BC%89%EF%BC%9A%20tcp_syn_retires%20%E7%9A%84%E5%8F%82%E6%95%B0%E6%9D%A5%E9%99%90%E5%88%B6%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%88syn%E5%8C%85%EF%BC%89%E7%9A%84%E9%87%8D%E4%BC%A0%E6%AC%A1%E6%95%B0%EF%BC%8C%20%E9%BB%98%E8%AE%A4%E4%B8%BA5%E6%AC%A1,%E3%80%82%20%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%88ack%2Back%E5%8C%85%EF%BC%89%EF%BC%9A%20tcp_synack_retires%20%E7%9A%84%E5%8F%82%E6%95%B0%E6%9D%A5%E9%99%90%E5%88%B6%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%88ack%2Bsyn%E5%8C%85%EF%BC%89%E7%9A%84%E9%87%8D%E4%BC%A0%E6%AC%A1%E6%95%B0%EF%BC%8C%20%E9%BB%98%E8%AE%A4%E4%B8%BA5%E6%AC%A1%20%E3%80%82